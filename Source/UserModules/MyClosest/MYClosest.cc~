//    This program is free software; you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation; either version 2 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program; if not, write to the Free Software
//    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//    See http://www.ikaros-project.org/ for more information.

#include "MYClosest.h"
#include <math.h>

using namespace ikaros;

void
MYClosest::Init()
{

  depth =  GetInputMatrix("depth");
  size_x = GetInputSizeX("depth");
  size_y = GetInputSizeY("depth"); 
  dist = GetOutputArray("CloseDist");
  distM = GetOutputArray("CloseDistM");
  point_position = GetOutputArray("ClosePosition");

}

void
MYClosest::Tick()
{
  float sm = depth[0][0];
  for(int j=0; j<size_y; j++){
    for(int i=0; i<size_x; i++){
      if(depth[j][i]<sm){
	sm = depth[j][i];
	point_position[0] = i;
	point_position[1] = j;
      }
    }
  }
  distM[0]= 1.0 / (sm*1023 * -0.0030711016 + 3.3309495161);//Probably not so good

  distM[1] = 0.1236 * tanf(sm*1023/2842.5 + 1.1863);

  distM[2] = 348/(1091.5-sm*1023);

  dist[0]=sm;
  point_position[0]=point_position[0]/size_x;
  point_position[1]=point_position[1]/size_y;
}


